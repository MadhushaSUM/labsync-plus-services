import crypto from 'crypto';

const ALGORITHM = 'aes-256-gcm';
const KEY = process.env.ENCRYPTION_KEY || '01234567890123456789012345678901';

export async function decryptQueryString(encryptedString: string) {
    // Revert the URL-safe Base64 string back to standard Base64.
    let base64 = encryptedString.replace(/-/g, '+').replace(/_/g, '/');
    // Add padding if needed
    while (base64.length % 4 !== 0) {
        base64 += '=';
    }
    const payloadBuffer = Buffer.from(base64, 'base64');

    // Extract the IV, authentication tag, and ciphertext.
    // For AES-256-GCM: IV is 12 bytes, authTag is 16 bytes.
    const iv = payloadBuffer.slice(0, 12);
    const authTag = payloadBuffer.slice(12, 28);
    const encryptedText = payloadBuffer.slice(28);

    // Create the decipher
    const decipher = crypto.createDecipheriv(ALGORITHM, Buffer.from(KEY, 'utf8'), iv);
    decipher.setAuthTag(authTag);

    // Decrypt the ciphertext
    const decrypted = Buffer.concat([
        decipher.update(encryptedText),
        decipher.final()
    ]);

    const splitted = decrypted.toString('utf8').split(",");
    const registrationId = Number(splitted[0].split(":")[1]);
    const investigationId = Number(splitted[1].split(":")[1]);

    if (!registrationId || !investigationId) {
        throw new Error("Invalid request!");

    }

    return { registrationId, investigationId };
}

export async function encryptQueryString(registrationId: number, investigationId: number) {
    // Generate a random Initialization Vector (IV). 12 bytes is recommended for GCM.
    const iv = crypto.randomBytes(12);

    // Create a cipher using AES-256-GCM
    const cipher = crypto.createCipheriv(ALGORITHM, Buffer.from(KEY, 'utf8'), iv);
    const encryptedBuffer = Buffer.concat([
        cipher.update(`registrationId:${registrationId},investigationId:${investigationId}`, 'utf8'),
        cipher.final()
    ]);

    // Get the authentication tag generated by GCM
    const authTag = cipher.getAuthTag();

    // Concatenate IV + authTag + encrypted content into one Buffer.
    // iv (12 bytes) | authTag (16 bytes) | ciphertext (variable)
    const payloadBuffer = Buffer.concat([iv, authTag, encryptedBuffer]);

    // Encode the result in Base64 and then make it URL-safe
    let encryptedString = payloadBuffer.toString('base64');
    encryptedString = encryptedString.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');

    return encryptedString;
}